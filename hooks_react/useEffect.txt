

## **1. Definition**

`useEffect` is a React Hook that lets you **run side effects** in functional components.
A **side effect** is anything that affects something outside the component’s render process, like:

* Fetching data from an API
* Working with `setTimeout` / `setInterval`
* Directly manipulating the DOM
* Subscribing to events

Before Hooks, these side effects lived in **class lifecycle methods** like `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`.
`useEffect` combines them into **one unified API**.

---

## **2. Syntax**

```javascript
useEffect(() => {
  // side effect code here
  return () => {
    // cleanup code here (optional)
  };
}, [dependencies]);
```

* **Effect function** → Runs after render.
* **Cleanup function** → Runs before the effect re-runs or before component unmounts.
* **Dependency array** → Controls when the effect runs.

---

## **3. Example: Log Message**

```javascript
import React, { useState, useEffect } from "react";

function Logger() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log(`Count changed to: ${count}`);
  }, [count]); // runs whenever count changes

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={() => setCount(count + 1)}>Increase</button>
    </div>
  );
}

export default Logger;
```

---

## **4. Workflow**

1. Component renders → UI is displayed.
2. React runs the **effect** after painting the screen.
3. If dependencies change, effect runs again.
4. Cleanup runs before next effect execution or when component unmounts.

---

## **5. Key Points**

* **No dependencies (`[]`)** → effect runs only once after the first render (like `componentDidMount`).
* **With dependencies (`[var]`)** → effect runs whenever `var` changes.
* **No dependency array** → effect runs **after every render** (can cause performance issues).
* **Cleanup function** is optional, but **important for avoiding memory leaks** (e.g., clearing intervals, removing event listeners).
* Effects **always** run after the browser has painted.

---

## **6. Example Variations**

### **Run once (fetch data example)**

```javascript
useEffect(() => {
  console.log("Component mounted");
}, []);
```

### **Cleanup example**

```javascript
useEffect(() => {
  const timer = setInterval(() => {
    console.log("Tick");
  }, 1000);

  return () => {
    clearInterval(timer); // cleanup
  };
}, []);
```

---


---

## **1. Live Chat App – WebSocket connection**

When building a chat app, you often use **WebSocket** to get live messages.
If you don’t close the connection when the user leaves, the server will keep sending data → wasted resources.

```javascript
import { useEffect } from "react";

function ChatRoom() {
  useEffect(() => {
    const socket = new WebSocket("wss://mychatapp.com");

    socket.onmessage = (event) => {
      console.log("New message:", event.data);
    };

    return () => {
      socket.close(); // ✅ Close connection when leaving room
    };
  }, []);

  return <h1>Welcome to the chat room</h1>;
}
```

---

## **2. Social Media App – Scroll Listener**

In apps like Instagram or Twitter, you might track **scroll position** for features like infinite scrolling.
If you don’t remove the listener when leaving the page, it keeps running → performance drop.

```javascript
import { useEffect } from "react";

function Feed() {
  useEffect(() => {
    const handleScroll = () => {
      console.log("Scrolling...");
    };

    window.addEventListener("scroll", handleScroll);

    return () => {
      window.removeEventListener("scroll", handleScroll); // ✅ Remove listener
    };
  }, []);

  return <div>Posts here...</div>;
}
```

---

## **3. E-commerce App – Auto Refresh Cart**

Say your cart auto-refreshes every 5 seconds.
If you don’t clear the interval when the user leaves, the timer keeps running in the background.

```javascript
import { useEffect } from "react";

function Cart() {
  useEffect(() => {
    const intervalId = setInterval(() => {
      console.log("Fetching updated cart...");
    }, 5000);

    return () => {
      clearInterval(intervalId); // ✅ Stop refreshing on unmount
    };
  }, []);

  return <h1>Your Cart</h1>;
}
```

---

## **4. Fitness Tracker – Geolocation Tracking**

If your app tracks location for a workout session, you must stop it when the session ends.

```javascript
import { useEffect } from "react";

function Tracker() {
  useEffect(() => {
    const watchId = navigator.geolocation.watchPosition((pos) => {
      console.log("Location:", pos.coords);
    });

    return () => {
      navigator.geolocation.clearWatch(watchId); // ✅ Stop tracking
    };
  }, []);

  return <h1>Tracking your run...</h1>;
}
```

---

## **5. Music Player – Audio Cleanup**

If you play music in a component and don’t pause/stop it when leaving, it’ll keep playing.

```javascript
import { useEffect } from "react";

function Player() {
  useEffect(() => {
    const audio = new Audio("/song.mp3");
    audio.play();

    return () => {
      audio.pause(); // ✅ Stop music when leaving
      audio.currentTime = 0;
    };
  }, []);

  return <h1>Playing song...</h1>;
}
```

---

Alright — here’s a **single React demo project** that shows all the real-world `useEffect` cleanup examples in one place, using a simple tab switcher so you can try them live.

---

```javascript
import React, { useState, useEffect } from "react";

// 1. Chat Room
function ChatRoom() {
  useEffect(() => {
    const socket = new WebSocket("wss://echo.websocket.org");
    socket.onmessage = (event) => {
      console.log("New message:", event.data);
    };
    socket.onopen = () => {
      socket.send("Hello from ChatRoom!");
    };

    return () => {
      console.log("Closing chat socket...");
      socket.close();
    };
  }, []);

  return <h2>ChatRoom: WebSocket opened. Check console logs.</h2>;
}

// 2. Feed Scroll Listener
function Feed() {
  useEffect(() => {
    const handleScroll = () => {
      console.log("User is scrolling...");
    };
    window.addEventListener("scroll", handleScroll);

    return () => {
      console.log("Removing scroll listener...");
      window.removeEventListener("scroll", handleScroll);
    };
  }, []);

  return <h2>Feed: Scroll the page and check console logs.</h2>;
}

// 3. Cart Auto Refresh
function Cart() {
  useEffect(() => {
    const intervalId = setInterval(() => {
      console.log("Fetching updated cart...");
    }, 3000);

    return () => {
      console.log("Stopping cart refresh...");
      clearInterval(intervalId);
    };
  }, []);

  return <h2>Cart: Auto-refresh every 3s. Check console logs.</h2>;
}

// 4. Fitness Tracker
function Tracker() {
  useEffect(() => {
    if ("geolocation" in navigator) {
      const watchId = navigator.geolocation.watchPosition((pos) => {
        console.log("Location:", pos.coords.latitude, pos.coords.longitude);
      });

      return () => {
        console.log("Stopping location tracking...");
        navigator.geolocation.clearWatch(watchId);
      };
    }
  }, []);

  return <h2>Tracker: Watching your location (if allowed).</h2>;
}

// 5. Music Player
function Player() {
  useEffect(() => {
    const audio = new Audio("https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3");
    audio.play();

    return () => {
      console.log("Stopping music...");
      audio.pause();
      audio.currentTime = 0;
    };
  }, []);

  return <h2>Player: Playing song...</h2>;
}

// Main App with Tabs
export default function App() {
  const [tab, setTab] = useState("chat");

  const renderTab = () => {
    switch (tab) {
      case "chat": return <ChatRoom />;
      case "feed": return <Feed />;
      case "cart": return <Cart />;
      case "tracker": return <Tracker />;
      case "player": return <Player />;
      default: return null;
    }
  };

  return (
    <div style={{ padding: "20px" }}>
      <h1>useEffect Cleanup Examples</h1>
      <div style={{ marginBottom: "10px" }}>
        <button onClick={() => setTab("chat")}>Chat Room</button>
        <button onClick={() => setTab("feed")}>Feed Scroll</button>
        <button onClick={() => setTab("cart")}>Cart Auto Refresh</button>
        <button onClick={() => setTab("tracker")}>Fitness Tracker</button>
        <button onClick={() => setTab("player")}>Music Player</button>
      </div>
      <div>{renderTab()}</div>
    </div>
  );
}
```

---

### How to Test:

1. Create a new **React app** (`npx create-react-app cleanup-demo`).
2. Replace `App.js` with the code above.
3. Open **browser console** to see logs.
4. Switch between tabs and watch how **cleanup stops background tasks**.

---



